<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--
    namespace的作用：利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定
-->
<mapper namespace="com.demo.mapper.BlogMapper">

    <!--
        cache：该命名空间的缓存配置。
        cache-ref：引用其它命名空间的缓存配置。
        resultMap：自定义结果集映射规则
        sql：可被其它语句引用的可重用语句块。
        insert：映射插入语句。
        update：映射更新语句。
        delete：映射删除语句。
        select：映射查询语句
    -->
    <!--
        select 元素允许你配置很多属性来配置每条语句的行为细节
        <select
          id="selectPerson" 	            在命名空间中唯一的标识符，可以被用来引用这条语句
          parameterType="int"               将会传入这条语句的参数的类全限定名或别名。这个属性是可选的
          resultType="hashmap"              期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个
          resultMap="personResultMap"       对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个
          flushCache="false"                将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false
          useCache="true"                   将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true
          timeout="10"                      这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）
          fetchSize="256"                   这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）
          statementType="PREPARED"          可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED
          resultSetType="FORWARD_ONLY"      FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）
          resultOrdered                     这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：false
          resultSets                        这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔
          >
    -->

    <select id="selectBlog" resultType="com.demo.entity.Blog">
        select * from Blog where id = #{id}
    </select>

    <!--    <select id="selectPerson" parameterType="int" resultType="hashmap">-->
    <!--        SELECT * FROM PERSON WHERE ID = #{id}-->
    <!--    </select>-->

    <!--
        insert, update 和 delete
        <insert
          id="insertAuthor"
          parameterType="domain.blog.Author"
          flushCache="true"                         将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true
          statementType="PREPARED"
          keyProperty=""                            仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称
          keyColumn=""                              （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称
          useGeneratedKeys=""                       （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false
          timeout="20"
          >

        <update
          id="updateAuthor"
          parameterType="domain.blog.Author"
          flushCache="true"
          statementType="PREPARED"
          timeout="20"
          >

        <delete
          id="deleteAuthor"
          parameterType="domain.blog.Author"
          flushCache="true"
          statementType="PREPARED"
          timeout="20"
          >
        -->

    <insert id="insertAuthor">
        insert into Author (id,username,password,email,bio)
        values (#{id},#{username},#{password},#{email},#{bio})
    </insert>

    <update id="updateAuthor">
        update Author set
                          username = #{username},
                          password = #{password},
                          email = #{email},
                          bio = #{bio}
        where id = #{id}
    </update>

    <delete id="deleteAuthor">
        delete from Author where id = #{id}
    </delete>

    <!--多行插入-->
    <insert id="insertAuthor" useGeneratedKeys="true"
            keyProperty="id">
        insert into Author (username, password, email, bio) values
        <foreach item="item" collection="list" separator=",">
            (#{item.username}, #{item.password}, #{item.email}, #{item.bio})
        </foreach>
    </insert>

    <!--
        keyProperty	        selectKey 语句结果应该被设置到的目标属性。如果生成列不止一个，可以用逗号分隔多个属性名称。
        keyColumn	        返回结果集中生成列属性的列名。如果生成列不止一个，可以用逗号分隔多个属性名称。
        resultType	        结果的类型。通常 MyBatis 可以推断出来，但是为了更加准确，写上也不会有什么问题。MyBatis 允许将任何简单类型用作主键的类型，包括字符串。如果生成列不止一个，则可以使用包含期望属性的 Object 或 Map。
        order	            可以设置为 BEFORE 或 AFTER。如果设置为 BEFORE，那么它首先会生成主键，设置 keyProperty 再执行插入语句。如果设置为 AFTER，那么先执行插入语句，然后是 selectKey 中的语句 - 这和 Oracle 数据库的行为相似，在插入语句内部可能有嵌入索引调用。
        statementType	    和前面一样，MyBatis 支持 STATEMENT，PREPARED 和 CALLABLE 类型的映射语句，分别代表 Statement, PreparedStatement 和 CallableStatement 类型。
    -->
    <!--
        <selectKey
            keyProperty="id"
            resultType="int"
            order="BEFORE"
            statementType="PREPARED"
            >
    -->

    <!--这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。-->
    <sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>

    <select id="selectUsers" resultType="map">
        select
        <include refid="userColumns"><property name="alias" value="t1"/></include>,
        <include refid="userColumns"><property name="alias" value="t2"/></include>
        from some_table t1
        cross join some_table t2
    </select>

    <sql id="sometable">
        ${prefix}Table
    </sql>

    <sql id="someinclude">
        from
        <include refid="${include_target}"/>
    </sql>

    <select id="select" resultType="map">
        select
        field1, field2, field3
        <include refid="someinclude">
            <property name="prefix" value="Some"/>
            <property name="include_target" value="sometable"/>
        </include>
    </select>

    <select id="selectUsers" resultType="User">
        select id, username, password
        from users
        where id = #{id}
    </select>

    <!--如果 User 类型的参数对象传递到了语句中，会查找 id、username 和 password 属性，然后将它们的值传入预处理语句的参数中-->
    <insert id="insertUser" parameterType="User">
        insert into users (id, username, password)
        values (#{id}, #{username}, #{password})
    </insert>

    <!--
        就是想直接在 SQL 语句中直接插入一个不转义的字符串
        1.#{} 为参数占位符?，即sql预编译
        2.${} 为字符串替换，即sql拼接
    -->
    ORDER BY ${columnName}

    <!--如果列名和属性名不能匹配上，可以在 SELECT 语句中设置列别名-->
    <select id="selectUsers" resultType="User">
        select
               表的字段名             类的属性名
            user_id             as "id",
            user_name           as "userName",
            hashed_password     as "hashedPassword"
        from some_table
        where id = #{id}
    </select>
    <!--自定义某个javaBean的封装规则
        type：自定义规则的Java类型
        id：唯一id方便引用
    -->
    <resultMap id="userResultMap" type="User">
        <!--id：指定主键列的封装规则
        property：指定对应的javabean属性
        column：数据库的列名
        -->
        <id property="id" column="user_id" />
        <!--result：定义普通列的封装规则
        property：指定对应的javabean属性
        column：数据库的列名
        -->
        <result property="username" column="user_name"/>
        <result property="password" column="hashed_password"/>
    </resultMap>

    <select id="selectUsers" resultMap="userResultMap">
        select user_id, user_name, hashed_password
        from some_table
        where id = #{id}
    </select>

    <!-- 非常复杂的结果映射
        constructor - 用于在实例化类时，注入结果到构造方法中
            idArg - ID 参数；标记出作为 ID 的结果可以帮助提高整体性能
            arg - 将被注入到构造方法的一个普通结果
        id – 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能
        result – 注入到字段或 JavaBean 属性的普通结果
        association – 一个复杂类型的关联；许多结果将包装成这种类型
            嵌套结果映射 – 关联可以是 resultMap 元素，或是对其它结果映射的引用
        collection – 一个复杂类型的集合
            嵌套结果映射 – 集合可以是 resultMap 元素，或是对其它结果映射的引用
        discriminator – 使用结果值来决定使用哪个 resultMap
            case – 基于某些值的结果映射
                嵌套结果映射 – case 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射
    -->
    <!--
        ResultMap 的属性列表
        id	当前命名空间中的一个唯一标识，用于标识一个结果映射。
        type	类的完全限定名, 或者一个类型别名（关于内置的类型别名，可以参考上面的表格）。
        autoMapping	如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。默认值：未设置（unset）。
    -->
    <resultMap id="detailedBlogResultMap" type="Blog">
        <constructor>
            <idArg column="blog_id" javaType="int"/>
        </constructor>
        <result property="title" column="blog_title"/>
        <!--association可以指定联合的javaBean对象
            property：指定哪个属性是联合的对象
            javaType：指定这个属性对象的类型[不能省略]
        -->
        <association property="author" javaType="Author">
            <id property="id" column="author_id"/>
            <result property="username" column="author_username"/>
            <result property="password" column="author_password"/>
            <result property="email" column="author_email"/>
            <result property="bio" column="author_bio"/>
            <result property="favouriteSection" column="author_favourite_section"/>
        </association>
        <!--collection定义关联集合类型的属性的封装规则
        ofType：指定集合里面元素的类型
        -->
        <collection property="posts" ofType="Post">
            <!--定义这个集合中元素的封装规则-->
            <id property="id" column="post_id"/>
            <result property="subject" column="post_subject"/>
            <association property="author" javaType="Author"/>
            <collection property="comments" ofType="Comment">
                <id property="id" column="comment_id"/>
            </collection>
            <collection property="tags" ofType="Tag" >
                <id property="id" column="tag_id"/>
            </collection>
            <!--鉴别器：mybatis可以使用discriminator判断某列的值，然后根据某列的值改变封装行为
                column：指定判断的列名
                javaType：列值对应的java类型
            -->
            <discriminator javaType="int" column="draft">
                <case value="1" resultType="DraftPost"/>
            </discriminator>
        </collection>
    </resultMap>

    <!--分步查询-->
    <resultMap id="blogResult" type="Blog">
    <!--association定义关联对象的封装规则
        select：表明当前属性是调用select指定的方法查出的结果
        column：指定将哪一列的值传给这个方法
    -->
        <association property="author" column="author_id" javaType="Author" select="selectAuthor"/>
    </resultMap>

    <select id="selectBlog" resultMap="blogResult">
        SELECT * FROM BLOG WHERE ID = #{id}
    </select>

    <select id="selectAuthor" resultType="Author">
        SELECT * FROM AUTHOR WHERE ID = #{id}
    </select>

    <!--集合的嵌套 Select 查询-->
    <resultMap id="blogResult" type="Blog">
        <collection property="posts" javaType="ArrayList" column="id" ofType="Post" select="selectPostsForBlog"/>
    </resultMap>

    <select id="selectBlog" resultMap="blogResult">
        SELECT * FROM BLOG WHERE ID = #{id}
    </select>

    <select id="selectPostsForBlog" resultType="Post">
        SELECT * FROM POST WHERE BLOG_ID = #{id}
    </select>

    <!--扩展：多列的值传递过去
            将多列的值封装map传递
            column="{key1=column1,key2=column2}"
            fetchType=lazy表示使用延迟加载
            eager：立即加载
    -->


    <!--id & result-->
    <id property="id" column="post_id"/>
    <result property="subject" column="post_subject"/>

    <!--id与result的区别-->


    <!--动态sql-->

    <select id="findActiveBlogLike" resultType="com.demo.entity.Blog">
        select * from blog where state = 'ACTIVE'
        <if test="title != null">
            and title like #{title}
        </if>
        <if test="author != null and author.name != null">
            and author_name like #{author.name}
        </if>
    </select>

    <!--从多个条件中选择一个使用-->
    <select id="findActiveBlogLike" resultType="Blog">
        select * from blog where state = 'ACTIVE'
        <choose>   <!--相当于switch-->
            <when test="title != null">    <!--相当于case-->
                and title like #{title}
            </when>
            <when test="author != null and author.name != null">
                and author_name like #{author.name}
            </when>
            <otherwise>    <!--相当于default-->
                and featured = 1
            </otherwise>
        </choose>
    </select>

    <!--建议使用这种方式-->
    <select id="findActiveBlogLike"
            resultType="Blog">
        SELECT * FROM BLOG
        <where>
            <if test="state != null">
                state = #{state}
            </if>
            <if test="title != null">
                AND title like #{title}
            </if>
            <if test="author != null and author.name != null">
                AND author_name like #{author.name}
            </if>
        </where>
    </select>

    <!--可以通过自定义 trim 元素来定制 where 元素的功能-->
    <trim prefix="WHERE" prefixOverrides="AND |OR ">
        ...
    </trim>

    <!--用于动态更新语句的类似解决方案叫做 set-->
    <update id="updateAuthorIfNecessary">
        update Author
        <set>
            <if test="username != null">username=#{username},</if>
            <if test="password != null">password=#{password},</if>
            <if test="email != null">email=#{email},</if>
            <if test="bio != null">bio=#{bio}</if>
        </set>
        where id=#{id}
    </update>

    <!--对集合进行遍历（尤其是在构建 IN 条件语句的时候）-->
    <!--index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。-->
    <select id="selectPostIn" resultType="domain.blog.Post">
        SELECT *
        FROM POST P
        WHERE ID in
        <foreach item="item" index="index" collection="list"
                 open="(" separator="," close=")">
            #{item}
        </foreach>
    </select>

    <!--bind 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。-->
    <select id="selectBlogsLike" resultType="Blog">
        <bind name="pattern" value="'%' + _parameter.getTitle() + '%'" />
        SELECT * FROM BLOG
        WHERE title LIKE #{pattern}
    </select>

</mapper>